/**
 * SPINdle (version 2.2.4)
 * Copyright (C) 2009-2014 NICTA Ltd.
 *
 * This file is part of SPINdle project.
 * 
 * SPINdle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * SPINdle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with SPINdle.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author H.-P. Lam (oleklam@gmail.com), National ICT Australia - Queensland Research Laboratory 
 */
package spindle.io.parser;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.List;
import java.util.Map;

import spindle.core.dom.Conclusion;
import spindle.core.dom.ConclusionType;
import spindle.core.dom.DomUtilities;
import spindle.core.dom.Literal;
import spindle.core.dom.LiteralVariable;
import spindle.core.dom.Rule;
import spindle.core.dom.RuleType;
import spindle.core.dom.Superiority;
import spindle.core.dom.Theory;
import spindle.io.ParserException;
import spindle.io.outputter.DflTheoryOutputter;
import spindle.io.parser.impl.DflTheoryParser2base;
import spindle.io.parser.impl.ParseException;
import spindle.sys.AppLogger;

/**
 * Defeasible theory and conclusions parser for theory represented using DFL.<br/>
 * This is a wrapper class for the DFL theory parser generated by <a href="http://javacc.java.net/">JavaCC</a>.
 * It is used to replace the DFL theory parser written since version 1.0.0 ({@link spindle.io.parser.DflTheoryParser}).
 * 
 * @author H.-P. Lam (oleklam@gmail.com), National ICT Australia - Queensland Research Laboratory
 * @since version 2.1.0
 * @version Last modified 2012.05.06
 * @see spindle.io.parser.DflTheoryParser
 */
public class DflTheoryParser2 extends AbstractTheoryParser {
	public static final String PARSER_TYPE = DflTheoryOutputter.OUTPUTTER_TYPE;
	private static DflTheoryParser2 INSTANCE = null;

	public static Literal extractLiteral(final String literalStr) throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		return INSTANCE.parseLiteral(literalStr);
	}

	public static LiteralVariable extractLiteralVariable(final String literalVariableString) throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		Literal literal = INSTANCE.parseLiteral(literalVariableString);
		return DomUtilities.getLiteralVariable(literal);
	}

	public static Theory getTheory(String theoryString, AppLogger logger) throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		return INSTANCE.getTheory(new ByteArrayInputStream(theoryString.getBytes()));
	}

	public static Map<Literal, Map<ConclusionType, Conclusion>> getConclusions(String conclusionsString, AppLogger logger)
			throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		return INSTANCE.generateConclusions(new ByteArrayInputStream(conclusionsString.getBytes()));
	}

	public static Rule extractRuleStr(final String rule) throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		return INSTANCE.parseRule(rule);
	}

	public static Superiority extractSuperiorityStr(final String superiorityStr) throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		return INSTANCE.parseSuperiority(superiorityStr);
	}

	public static RuleType getRuleType(final String theoryString) throws ParserException {
		return RuleType.getRuleType(theoryString);
	}

	public static String getLiteralFunctionEvaluationString(final String literalFunctionStr, //
			Map<LiteralVariable, LiteralVariable> literalVariableMapping, Map<LiteralVariable, String> literalBooleanFunctionAnswers)
			throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		String str = literalFunctionStr;
		if (!literalFunctionStr.startsWith("$")) str = "$" + literalFunctionStr;
		if (!literalFunctionStr.endsWith("$")) str += "$";
		return INSTANCE.evaluateLiteralFunction(str, literalVariableMapping, literalBooleanFunctionAnswers);
	}

	public static List<String> getTokenizeLiteralFunction(final String literalFunctionStr, //
			Map<LiteralVariable, LiteralVariable> literalVariableMapping, Map<LiteralVariable, String> literalBooleanFunctionAnswers)
			throws ParserException {
		if (null == INSTANCE) INSTANCE = new DflTheoryParser2();
		String str = literalFunctionStr;
		if (!literalFunctionStr.startsWith("$")) str = "$" + literalFunctionStr;
		if (!literalFunctionStr.endsWith("$")) str += "$";
		return INSTANCE.tokenizeLiteralFunction(str, literalVariableMapping, literalBooleanFunctionAnswers);
	}

	public DflTheoryParser2() {
		super(PARSER_TYPE);
	}

	@Override
	protected void generateTheory(InputStream ins) throws ParserException {
		DflTheoryParser2base parserBase = new DflTheoryParser2base(ins);
		try {
			theory = parserBase.parseTheory();
		} catch (ParseException e) {
			throw new ParserException(e);
		}
	}

	@Override
	protected Map<Literal, Map<ConclusionType, Conclusion>> generateConclusions(InputStream ins) throws ParserException {
		DflTheoryParser2base parserBase = new DflTheoryParser2base(ins);
		try {
			return parserBase.parseConclusions();
		} catch (ParseException e) {
			throw new ParserException(e);
		}
	}

	protected Literal parseLiteral(String s) throws ParserException {
		try {
			DflTheoryParser2base parserBase = new DflTheoryParser2base(new ByteArrayInputStream(s.getBytes()));
			return parserBase.parseLiteral();
		} catch (Exception e) {
			throw new ParserException(e);
		}
	}

	protected Rule parseRule(String s) throws ParserException {
		try {
			DflTheoryParser2base parserBase = new DflTheoryParser2base(new ByteArrayInputStream(s.getBytes()));
			return parserBase.parseRule();
		} catch (Exception e) {
			throw new ParserException(e);
		}
	}

	protected Superiority parseSuperiority(String s) throws ParserException {
		try {
			DflTheoryParser2base parserBase = new DflTheoryParser2base(new ByteArrayInputStream(s.getBytes()));
			List<Superiority> superiority = parserBase.parseSuperiority();
			return superiority.size() > 0 ? superiority.get(0) : null;
		} catch (Exception e) {
			throw new ParserException(e);
		}
	}

	protected String evaluateLiteralFunction(String s, Map<LiteralVariable, LiteralVariable> literalVariableMapping,
			Map<LiteralVariable, String> literalBooleanFunctionAnswers) throws ParserException {
		try {
			DflTheoryParser2base parserBase = new DflTheoryParser2base(new ByteArrayInputStream(s.getBytes()));
			String literalFunction = parserBase.evaluateLiteralFunction(literalVariableMapping, literalBooleanFunctionAnswers);
			return literalFunction;
		} catch (Exception e) {
			throw new ParserException(e);
		}
	}

	protected List<String> tokenizeLiteralFunction(String s, Map<LiteralVariable, LiteralVariable> literalVariableMapping,
			Map<LiteralVariable, String> literalBooleanFunctionAnswers) throws ParserException {
		try {
			DflTheoryParser2base parserBase = new DflTheoryParser2base(new ByteArrayInputStream(s.getBytes()));
			List<String> literalList = parserBase.tokenizeLiteralFunction(literalVariableMapping, literalBooleanFunctionAnswers);
			return literalList;
		} catch (Exception e) {
			throw new ParserException(e);
		}
	}
}
