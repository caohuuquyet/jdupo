/**
 * SPINdle (version 2.2.4)
 * Copyright (C) 2009-2014 NICTA Ltd.
 *
 * This file is part of SPINdle project.
 * 
 * SPINdle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * SPINdle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with SPINdle.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author H.-P. Lam (oleklam@gmail.com), National ICT Australia - Queensland Research Laboratory 
 */
package spindle.io.outputter;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Date;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerFactory;

import org.w3c.dom.Document;

import spindle.core.dom.Conclusion;
import spindle.core.dom.Theory;
import spindle.io.OutputterException;
import spindle.io.TheoryOutputter;
import spindle.sys.AppConst;
import spindle.sys.AppModuleBase;
import spindle.sys.Messages;
import spindle.sys.message.ErrorMessage;

/**
 * Base class for defeasible theory outputter.
 * 
 * @author H.-P. Lam (oleklam@gmail.com), National ICT Australia - Queensland Research Laboratory
 * @since version 1.0.0
 */
public abstract class AbstractTheoryOutputter extends AppModuleBase implements TheoryOutputter {
	protected static final String SYMBOL_NEGATION = DflTheoryConst.SYMBOL_NEGATION;
	protected static final String DEFAULT_RULE_LABEL_PREFIX = Theory.DEFAULT_RULE_LABEL_PREFIX;

	@Deprecated
	private static DocumentBuilder xmlDocumentBuilder = null;
	@Deprecated
	private static Transformer xmlTransformer = null;

	private String outputterType = null;

	protected AbstractTheoryOutputter(String outputterType) {
		super();
		if (null == outputterType) throw new IllegalArgumentException(Messages.getErrorMessage(ErrorMessage.IO_OUTPUTTER_TYPE_NULL));
		this.outputterType = outputterType.trim().toLowerCase();
	}

	public String getOutputterType() {
		return outputterType;
	}

	@Override
	public void save(OutputStream os, Theory theory) throws OutputterException {
		if (null == os) throw new OutputterException(ErrorMessage.IO_OUTPUT_STREAM_NULL);
		if (null == theory) throw new OutputterException(ErrorMessage.THEORY_NULL_THEORY);

		try {
			saveToStream(os, theory);
		} catch (Exception e) {
			throw new OutputterException(e);
		} finally {
			if (null != os) {
				try {
					os.flush();
					os.close();
				} catch (IOException e) {
				}
				os = null;
			}
		}
	}

	@Override
	public void save(OutputStream os, List<Conclusion> conclusionsAsList) throws OutputterException {
		if (null == os) throw new OutputterException(ErrorMessage.IO_OUTPUT_STREAM_NULL);
		if (null == conclusionsAsList) throw new OutputterException(ErrorMessage.CONCLUSION_NULL_CONCLUSIONS_SET);

		try {
			saveToStream(os, conclusionsAsList);
		} catch (Exception e) {
			throw new OutputterException(e);
		} finally {
			if (null != os) {
				try {
					os.flush();
					os.close();
				} catch (IOException e) {
				}
				os = null;
			}
		}
	}

	protected abstract void saveToStream(OutputStream os, Theory theory) throws OutputterException;

	protected abstract void saveToStream(OutputStream os, List<Conclusion> conclusionsAsList) throws OutputterException;

	// //////////////////////////////////////////////
	// common functions
	//

	protected static String getHeaderComment() {
		return "Defeasible theory generated by " + AppConst.APP_TITLE + " (ver. " + AppConst.APP_VERSION + ")";
	}

	protected static String getGenerationTimeString() {
		return "file generated at " + (new Date());
	}

	// //////////////////////////////////////////////
	// for XML document
	//
	@Deprecated
	protected Document getNewXmlDocument() throws ParserConfigurationException {
		if (null == xmlDocumentBuilder) {
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			xmlDocumentBuilder = factory.newDocumentBuilder();
		}
		return xmlDocumentBuilder.newDocument();
	}

	@Deprecated
	protected Transformer getXmlTransformer() throws TransformerConfigurationException {
		if (null == xmlTransformer) {
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			xmlTransformer = transformerFactory.newTransformer();
			xmlTransformer.setOutputProperty(OutputKeys.INDENT, "yes");
			xmlTransformer.setOutputProperty(OutputKeys.ENCODING, "utf8");
			xmlTransformer.setOutputProperty(OutputKeys.STANDALONE, "yes");
			xmlTransformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
		}
		return xmlTransformer;
	}

}
